1. 페치조인 개요

	페치 조인(fetch join) 실무에서 중요
	sql 종류가 아니고 jpql 성능최적화를 위해 제공
	sql을 한 번에 조회 가능
	join fetch 명령어 사용
	즉시로딩을 명시적으로 표현하는것과 비슷함
	지연로딩으로 새로운 데이터를 가져올때마다 쿼리를 날리기 때문에 쿼리가 너무 많이 사용됨(fetch 사용x 일때)
	fetch : 조인해서 필요한 데이터를 한 번에 모두 가져온다.
	지연로딩보다 fetch 조인을 우선적으로 실행한다.


2. 엔티티 페치조인
	
	String query = "select m from Member m"; --일반 쿼리
	String query = "select m from Member m join fetch m.team t"; //fetch 조인 쿼리 (select m.* from member m, Team t where m.team_id = t.id)
	            List<Member> resultList = em.createQuery(query, Member.class)
	                    .getResultList();

	            for (Member member1 : resultList) {
	                System.out.println("member1.getUsername() = " + member1.getUsername());
	                System.out.println("member1.getTeam().getName() = " + member1.getTeam().getName());
	            }
            


3. 컬렉션 페치 조인
	일대다 관계 컬렉션 페치 조인
	일대다 관계는 데이터가 중복되어 표출됨(뻥튀기)
	다대일 관계는 데이터 뻥튀기 일어나지 않음
	
	SQL의 DISTINCT 는 중복된 걸과를 제거하는 명령
	JPQL의 DISTINCT 2가지 기능 제공
		1) SQL에 DISTINCT를 추가
		2) 에플리케이션에서 엔티티 중복 제거 
		   -DB에서 가져온 데이터중 중복이 있으면 애플리케이션단에서 제거해준다.
		   -모든 데이터의 상태가 같은 데이터만 제거가 된다. 로우의 상태가 모두 일치할때
	
	String query = "select t from Team t join fetch t.members"; //(select t.* from member m, Team t where m.team_id = t.id)
  List<Team> resultList = em.createQuery(query, Team.class)
          .getResultList();
  for (Team team : resultList) {
      System.out.println("team.getName() = " + team.getName());
      System.out.println("team.getMembers() = " + team.getMembers().size());
  }
  

4. 페치조인과 일반조인의 차이
	JPQL은 결과를 반환할 때 연관관계 고려 x
	단지 SELECT 절에 지정한 엔티티만 조회할 뿐
	여기서는 팀 엔티티만 조회하고 회원 엔티티는 조회 X
	페치조인을 사용할 때만 연관된 엔티티도 함께 조회(즉시로딩)
	페치조인은 객체 그래프를 SQL 한번에 조회하는 기능
	
	엔티티 조회시 데이터 관계에 따른 N+1개만큼 쿼리가 나가는 현상을 페치조인으로 해결함
	
5. 페치조인의 특징과 한계
	페치조인 대상에게는 별칭을 줄 수 없다.
		ex)select DISTINCT t from Team t join fetch t.members as m 
	하이버네인트는 가능하지만 가급적 사용X
	둘 이상의 컬렉션은 페치조인 할 수 없다
		컬렉션의 페치조인은 하나만 지정할 수 있다.
	컬렉션을페치조인하면 페이징API(setFirstResult,setMaxResults)를 사용할 수 없다.
	다대일 일대일 단일값 관련 필드는 페치조인해도 페이징 가능
	하이버네이트는 경고 로그를 남기고 메모리에서 페이징(매우 위험)
		페이징 시 컬렉션의 여러 데이터가 다음 페이지로 넘어갈 때 짤릴 수 있고 짤린 데이터는 표출되지 않아서 사용할 수 없다.
		일대다 쿼리를 다대일 쿼리로 바꿔주면 페이징 문제를 해결할 수 있다.
	
	연관된 엔티티들을 SQL 한 번으로 조회(성능 최적화)
	엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선함
		@OneToMany(fetch = FetchType.LAZY) //글로벌 로딩 전략
	실무에서 글로벌 로딩 전략은 모두 지연로딩
	최적화가 필요한 곳은 페치 조인 적용(N+1이 발생하는 곳에서)
	
	모든것을 페치조인을 해결할 수는 없음
	페치조인은 객체 그래프를 유지할 떄 사용하면 효과적
	여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 하면,
	페치 조인보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적